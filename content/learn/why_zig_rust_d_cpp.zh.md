---
title: "有了 C++、D 和 Rust，为什么还需要 Zig？"
mobile_menu_title: "为什么还需要 Zig ..."
toc: true
---


## 没有隐式控制流

如果 Zig 代码看起来不像是在调用一个函数，那么它就不是。这意味着你可以确定下面的代码只会先调用 `foo()`，然后调用 `bar()`，不需要知道任何元素的类型，这一点也是可以保证的：

```zig
var a = b + c.d;
foo();
bar();
```

隐式控制流的例子：

- D 有 `@property` 函数，可以让你的方法调用看起来像是成员访问，因此在上面的例子中，`c.d` 可能会调用一个函数。
- C++，D 和 Rust 有运算符重载，因此 `+` 可能会调用一个函数。
- C++，D 和 Go 可以抛出和捕获异常，因此 `foo()` 可能会抛出一个异常，并且将会阻止 `bar()` 被调用。（当然，即使在 Zig 中 `foo()` 也可以存在死锁，并阻止 `bar()` 被调用，但是这可以发生在任何一个图灵完备的语言里。）

这个设计决定的目的是可读性。

## 没有隐式内存分配

换句话说，必须手动地写出堆分配。没有 `new` 关键字或其他任何使用堆分配器的语言功能（例如字符串连接运算符[1]）。整个堆的概念严格来说是在用户空间的。有一些标准库功能提供了堆分配器并且可以配合堆分配器，但这些都是可选的标准库特性，而不是内置在语言本身中的。如果你从不初始化堆分配器，那么你可以确信你的程序永远不会引起堆分配。

Zig 的标准库还很年轻，但我们的目标是让每一个使用分配器的函数都在运行时（或者仅在编译期）接受一个分配器参数。

这种设计理念的动机是让用户能够在认为必要时写出任何方式的自定义分配策略，而不是强迫甚至鼓励他们采用一种可能不适合他们需求的特定分配策略。例如，Rust 似乎鼓励使用单一的全局分配器，这并不适合很多用例，比如操作系统开发和高性能游戏开发。Zig 借鉴了 [Jai](https://www.youtube.com/watch?v=ciGQCP6HgqI) 对分配器的立场，因为该语言是由一个高性能游戏设计师为高性能游戏的用例开发的。

如前所述，这个话题还有点宽泛，随着 Zig 标准库的成熟，这个话题会变得更加具体。重点在于，堆分配是一个用户空间的概念，而不是内置在语言中的概念。

当然，Zig 不会有 Go 那样内置的垃圾收集器。

[Rust 标准库在内存不足时 panic （英文）](https://github.com/rust-lang/rust/issues/29802)

[1]：事实上有一个编译期字符串连接运算符（广义来说，是数组连接运算符），但它只能在编译期使用，所以仍然没有运行时的堆分配。

## 无标准库的一流支持

Zig 有一个完全可选的标准库，只有当你使用它时才会被编译到你的程序中。Zig 同时支持链接或不链接 libc。因此 Zig 非常适合裸机和高性能开发。

## 为库设计的可移植语言

编程的圣杯之一是代码重用。遗憾的是，在实践中我们发现自己多次重复发明轮子。很多时候这是有理由的：

 * 如果一个应用程序有实时性需求，那么任何使用垃圾收集或任何其他非确定性行为的库都将不予考虑。
 * 如果一门语言让人太容易忽略错误，因此不得不验证一个库是否正确地处理和抛出错误，就很容易因此放弃这个库并重新实现它，只有自己知道自己正确地处理了所有相关的错误。Zig 的设计使程序员能做的最懒的事情就是正确处理错误，因此人们可以合理地相信一个库会正确地抛出错误。
 * 目前，实事求是的说，C 语言是最通用、最可移植的语言。任何不具备与 C 代码互操作能力的语言都有可能被历史所抛弃。Zig 试图成为编写库的新的可移植语言，同时使导出函数直接符合 C ABI，并引入安全性和防止实现中的常见错误的语言设计。

## 为现有项目的构建系统和包管理器

Zig 是一门编程语言，但它也提供了一个构建系统和包管理器，即使在传统的 C/C++ 项目中也很有用。

你不仅可以用 Zig 代码代替 C 或 C++ 代码，还可以用 Zig 代替 autotools、cmake、make、scons、ninja 等。而在此之上，Zig（将）提供一个本地依赖的包管理器。这个构建系统的目的是为了使得即使一个项目的全部代码库都是 C 或 C++ 也能适用。

apt-get、pacman、homebrew 等系统包管理器对最终用户的体验很有帮助，但它们可能不足以满足开发人员的需求。有无语言专用的包管理器可以形成没有贡献者和有大量贡献者之间的差距。对于开源项目来说，项目构建的难度对潜在贡献者来说是一个巨大的障碍。特别是对于 C/C++ 项目来说，依赖关系可能是致命的，尤其是在没有包管理器的 Windows 上。即使只是构建 Zig 本身，大多数潜在的贡献者在 LLVM 依赖上也会遇到困难。Zig （将）为项目提供一种直接依赖原生库的方式——不需要依赖用户的系统包管理器来获得正确的版本，而且这种方式几乎可以保证不管使用的是什么系统，也不管目标平台是什么，都可以在第一次尝试时就成功地构建项目。

Zig 用一种使用声明式 API 的合理的语言来代替项目的构建系统。它还提供包管理系统，从而可以依赖其他 C 库。有了声明依赖的能力，就能实现更高层次的抽象，从而实现可重用高级代码的“增殖”。

## 简单性

C++、Rust 和 D 有大量的特性，它可能会打乱你正在编写的应用程序的实际含义。人们发现自己是在调试自己的编程语言知识，而不是调试应用程序本身。

Zig 没有宏也没有元编程，但仍然足够强大，可以清晰、不重复地表达复杂的程序。即使是在有宏的 Rust 里， `format!` 也是特例，它是在编译器内部实现的。与此同时 Zig 中的等价函数是在标准库中实现的，编译器中没有特例代码。

当你阅读 Zig 代码的时候，所有的东西都是一个简单的表达式或函数调用，没有运算符重载、属性方法、运行时调度、宏或隐式控制流。Zig 追求的是 C 语言的所拥有的美丽的简单性并除去其中的陷阱。

 * [与 Rust 的斗争（英文）](https://compileandrun.com/stuggles-with-rust.html)
 * [Way Cooler 因复杂性而放弃了 Rust（英文）](http://way-cooler.org/blog/2019/04/29/rewriting-way-cooler-in-c.html)
 * [转向 Zig 进行 ARM 开发（英文）](https://www.jishuwen.com/d/2Ap9)

## 工具性

可以从[下载页面](../../downloads/)下载 Zig。Zig 提供了 linux、windows、macos 和 freebsd 的二进制存档。你将得到：

* 通过下载并解压单个压缩包进行安装，无需配置系统。
* 静态编译，没有运行时依赖
* 使用成熟的、得到良好支持的 LLVM 基础架构，支持大多数主要平台，并进行深度优化。
* 开箱即用的支持大多数主要平台上交叉编译。
* 提供 libc 的源代码，在任何支持的平台上需要时都会动态编译。
* 包括带缓存的构建系统
* 编译具有 libc 依赖的 C 项目
